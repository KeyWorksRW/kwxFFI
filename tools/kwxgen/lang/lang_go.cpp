// Generated by GitHub Copilot. Directed and reviewed by Ralph Walden.
// Licensed under Apache 2.0. This file is not subject to copyright.

#include "lang_go.h"

#include "go_type_map.h"

#include "file_writer.h"
#include <algorithm>
#include <cctype>
#include <filesystem>
#include <iostream>
#include <set>
#include <sstream>
#include <vector>

namespace fs = std::filesystem;

namespace kwxgen
{

    // -------------------------------------------------------------------------
    // File header / preamble helpers
    // -------------------------------------------------------------------------

    namespace
    {

        void WriteGeneratedHeader(std::ostream& out)
        {
            out << "// Code generated by kwxgen. DO NOT EDIT.\n\n";
        }

        // Determine the Go type expression for a constant's return type.
        // Returns the Go wrapper around the C call, e.g., "int(C.expwxFOO())"
        // or "unsafe.Pointer(C.expwxFOO())".
        std::string GoConstantExpr(const ConstantDecl& c)
        {
            if (c.return_type == "int")
                return "int(C." + c.export_name + "())";

            // Pointer types (wxString*, const wxColour*, etc.) → unsafe.Pointer
            if (c.return_type.find('*') != std::string::npos)
                return "unsafe.Pointer(C." + c.export_name + "())";

            // Fallback: treat as int
            return "int(C." + c.export_name + "())";
        }

        // Check if any constant uses a pointer type (needs "unsafe" import).
        bool ConstantsNeedUnsafe(const std::vector<ConstantDecl>& constants)
        {
            return std::any_of(constants.begin(), constants.end(),
                               [](const ConstantDecl& c)
                               {
                                   return c.return_type.find('*') != std::string::npos;
                               });
        }

        // -----------------------------------------------------------------
        // Class generation helpers
        // -----------------------------------------------------------------

        // Strip common prefixes: "wxButton" → "Button", "kwxFoo" → "Foo", "ELJBar" → "Bar"
        std::string StripPrefix(const std::string& name)
        {
            if (name.size() > 2 && name[0] == 'w' && name[1] == 'x' && std::isupper(name[2]))
                return name.substr(2);
            if (name.size() > 3 && name.substr(0, 3) == "kwx" && std::isupper(name[3]))
                return name.substr(3);
            if (name.size() > 3 && name.substr(0, 3) == "ELJ" && std::isupper(name[3]))
                return name.substr(3);
            return name;
        }

        // Lowercase a string: "TextCtrl" → "textctrl"
        std::string ToLower(const std::string& s)
        {
            std::string result;
            result.reserve(s.size());
            for (char c: s)
                result += static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
            return result;
        }

        // Go filename: "wxButton" → "button_gen.go"
        // Only strip the "wx" prefix — kwx/ELJ classes keep their prefix to
        // avoid collisions (e.g. kwxDropTarget vs wxDropTarget).
        std::string GoFileName(const std::string& className)
        {
            std::string stripped = className;
            if (className.size() > 2 && className[0] == 'w' && className[1] == 'x' &&
                std::isupper(static_cast<unsigned char>(className[2])))
                stripped = className.substr(2);
            return ToLower(stripped) + "_gen.go";
        }

        // Receiver variable: "Button" → "o", "TextCtrl" → "o"
        // Using uniform "o" to avoid name collisions with parameter names.
        std::string ReceiverVar(const std::string& /*goClassName*/)
        {
            return "o";
        }

        // Go reserved keywords that cannot be used as parameter names.
        // Returns a safe replacement, or the original name if not a keyword.
        std::string RenameGoKeyword(const std::string& name)
        {
            static const std::unordered_map<std::string, std::string> keywords = {
                { "type", "typ" },        { "select", "sel" }, { "range", "rng" },
                { "map", "mp" },          { "func", "fn" },    { "var", "v" },
                { "chan", "ch" },         { "go", "g" },       { "defer", "deferVal" },
                { "switch", "sw" },       { "case", "cs" },    { "default", "def" },
                { "interface", "iface" }, { "struct", "st" },  { "package", "pkg" },
                { "import", "imp" },      { "return", "ret" }, { "break", "brk" },
                { "continue", "cont" },   { "for", "loop" },   { "if", "cond" },
                { "else", "alt" },        { "goto", "jmp" },   { "fallthrough", "ft" },
            };
            auto it = keywords.find(name);
            return (it != keywords.end()) ? it->second : name;
        }

        // Ensure a Go identifier doesn't start with a digit (illegal in Go).
        // e.g. "3STATE" → "X3STATE"
        std::string SafeGoIdentifier(const std::string& name)
        {
            if (!name.empty() && std::isdigit(static_cast<unsigned char>(name[0])))
                return "X" + name;
            return name;
        }

        // Split comma-separated macro arg: "x, y" → {"x", "y"}
        std::vector<std::string> SplitMacroArg(const std::string& arg)
        {
            std::vector<std::string> parts;
            std::istringstream ss(arg);
            std::string part;
            while (std::getline(ss, part, ','))
            {
                auto start = part.find_first_not_of(" \t");
                auto end = part.find_last_not_of(" \t");
                if (start != std::string::npos)
                    parts.push_back(part.substr(start, end - start + 1));
            }
            return parts;
        }

        // Info about a single Go parameter (may be expanded from one C param).
        struct GoParam
        {
            std::string name;        // Go parameter name
            std::string go_type;     // Go type: "int", "bool", "string", "unsafe.Pointer"
            std::string cgo_expr;    // Expression to pass to C call
            std::string pre_call;    // Statement before C call (e.g., wxStr := NewWxString(...))
            std::string defer_call;  // Defer statement (e.g., defer wxStr.Free())
            bool needs_unsafe = false;
        };

        // Capitalize first letter of a string
        std::string Capitalize(const std::string& s)
        {
            if (s.empty())
                return s;
            std::string result = s;
            result[0] = static_cast<char>(std::toupper(static_cast<unsigned char>(result[0])));
            return result;
        }

        // Convert one Param to one or more GoParams.
        std::vector<GoParam> ConvertParam(const Param& p)
        {
            std::vector<GoParam> result;

            // TSelf is the receiver — skip in parameter list
            if (p.macro_name == "TSelf")
                return result;

            // Expanded geometry types: TPoint, TSize, TRect, TVector, etc.
            if (p.macro_name == "TPoint" || p.macro_name == "TSize" || p.macro_name == "TRect" ||
                p.macro_name == "TVector")
            {
                for (auto& raw: SplitMacroArg(p.macro_arg))
                {
                    auto n = RenameGoKeyword(raw);
                    result.push_back({ n, "int", "C.int(" + n + ")", "", "", false });
                }
                return result;
            }

            if (p.macro_name == "TPointLong" || p.macro_name == "TSizeLong" ||
                p.macro_name == "TRectLong" || p.macro_name == "TVectorLong")
            {
                for (auto& raw: SplitMacroArg(p.macro_arg))
                {
                    auto n = RenameGoKeyword(raw);
                    result.push_back({ n, "int", "C.long(" + n + ")", "", "", false });
                }
                return result;
            }

            if (p.macro_name == "TPointOut" || p.macro_name == "TSizeOut" ||
                p.macro_name == "TRectOut" || p.macro_name == "TVectorOut" ||
                p.macro_name == "TPointOutVoid" || p.macro_name == "TSizeOutVoid" ||
                p.macro_name == "TRectOutVoid" || p.macro_name == "TVectorOutVoid")
            {
                // Output geometry parameters — pass as unsafe.Pointer for each component
                for (auto& raw: SplitMacroArg(p.macro_arg))
                {
                    auto n = RenameGoKeyword(raw);
                    result.push_back({ n, "unsafe.Pointer", n, "", "", true });
                }
                return result;
            }

            if (p.macro_name == "TSizeOutDouble")
            {
                for (auto& raw: SplitMacroArg(p.macro_arg))
                {
                    auto n = RenameGoKeyword(raw);
                    result.push_back({ n, "unsafe.Pointer", n, "", "", true });
                }
                return result;
            }

            if (p.macro_name == "TColorRGB")
            {
                for (auto& raw: SplitMacroArg(p.macro_arg))
                {
                    auto n = RenameGoKeyword(raw);
                    result.push_back({ n, "int", "C.uchar(" + n + ")", "", "", false });
                }
                return result;
            }

            // Array types: expand to count + pointer
            if (p.macro_name == "TArrayString" || p.macro_name == "TArrayInt" ||
                p.macro_name == "TByteString" || p.macro_name == "TByteStringLazy")
            {
                auto names = SplitMacroArg(p.macro_arg);
                if (names.size() >= 2)
                {
                    auto n0 = RenameGoKeyword(names[0]);
                    auto n1 = RenameGoKeyword(names[1]);
                    result.push_back({ n0, "int", "C.int(" + n0 + ")", "", "", false });
                    result.push_back({ n1, "unsafe.Pointer", n1, "", "", true });
                }
                return result;
            }

            if (p.macro_name == "TArrayObjectOutVoid")
            {
                std::string name = RenameGoKeyword(p.param_name.empty() ? "arr" : p.param_name);
                result.push_back({ name, "unsafe.Pointer", name, "", "", true });
                return result;
            }

            // Single parameter
            GoParam gp;
            gp.name = RenameGoKeyword(p.param_name.empty() ? "arg" : p.param_name);

            if (p.macro_name == "TClass" && p.macro_arg == "wxString")
            {
                // wxString parameter: Go string → NewWxString bridge
                std::string wxVar = "wx" + Capitalize(gp.name);
                gp.go_type = "string";
                gp.pre_call = wxVar + " := NewWxString(" + gp.name + ")";
                gp.defer_call = "defer " + wxVar + ".Free()";
                gp.cgo_expr = wxVar + ".Ptr()";
                gp.needs_unsafe = false;
            }
            else if (p.macro_name == "TClass" || p.macro_name == "TClassRef")
            {
                gp.go_type = "unsafe.Pointer";
                gp.cgo_expr = gp.name;
                gp.needs_unsafe = true;
            }
            else if (p.macro_name == "TBool" || p.raw_type == "TBool")
            {
                gp.go_type = "bool";
                gp.cgo_expr = "boolToInt(" + gp.name + ")";
            }
            else if (p.raw_type == "TBoolInt" || p.raw_type == "TBool*")
            {
                gp.go_type = "int";
                gp.cgo_expr = "C.int(" + gp.name + ")";
            }
            else if (p.macro_name == "TClosureFun" || p.raw_type == "TClosureFun")
            {
                gp.go_type = "unsafe.Pointer";
                gp.cgo_expr = gp.name;
                gp.needs_unsafe = true;
            }
            else if (p.raw_type == "TStringVoid" || p.macro_name == "TStringVoid")
            {
                gp.go_type = "unsafe.Pointer";
                gp.cgo_expr = gp.name;
                gp.needs_unsafe = true;
            }
            else if (p.raw_type == "TArrayIntOutVoid" || p.raw_type == "TArrayIntPtrOutVoid" ||
                     p.raw_type == "TArrayStringOutVoid" || p.raw_type == "TByteStringOut" ||
                     p.raw_type == "TByteStringLazyOut")
            {
                gp.go_type = "unsafe.Pointer";
                gp.cgo_expr = gp.name;
                gp.needs_unsafe = true;
            }
            else if (p.raw_type == "TChar")
            {
                gp.go_type = "byte";
                gp.cgo_expr = "C.char(" + gp.name + ")";
            }
            else if (p.raw_type == "TUInt8")
            {
                gp.go_type = "uint8";
                gp.cgo_expr = "C.uchar(" + gp.name + ")";
            }
            else
            {
                // Plain C types
                std::string raw = p.raw_type;
                if (raw.empty() || raw == "int")
                {
                    gp.go_type = "int";
                    gp.cgo_expr = "C.int(" + gp.name + ")";
                }
                else if (raw == "long")
                {
                    gp.go_type = "int";
                    gp.cgo_expr = "C.long(" + gp.name + ")";
                }
                else if (raw == "unsigned" || raw == "unsigned int")
                {
                    gp.go_type = "uint";
                    gp.cgo_expr = "C.uint(" + gp.name + ")";
                }
                else if (raw == "unsigned long" || raw == "wxUIntPtr")
                {
                    gp.go_type = "uint";
                    gp.cgo_expr = "C.ulong(" + gp.name + ")";
                }
                else if (raw == "double")
                {
                    gp.go_type = "float64";
                    gp.cgo_expr = "C.double(" + gp.name + ")";
                }
                else if (raw == "float")
                {
                    gp.go_type = "float32";
                    gp.cgo_expr = "C.float(" + gp.name + ")";
                }
                else if (raw == "size_t")
                {
                    gp.go_type = "int";
                    gp.cgo_expr = "C.size_t(" + gp.name + ")";
                }
                else if (raw == "int*" || raw == "long*" || raw == "double*" ||
                         raw == "unsigned*" || raw == "const int*")
                {
                    gp.go_type = "unsafe.Pointer";
                    gp.cgo_expr = gp.name;
                    gp.needs_unsafe = true;
                }
                else if (raw.find('*') != std::string::npos)
                {
                    // Any other pointer type
                    gp.go_type = "unsafe.Pointer";
                    gp.cgo_expr = gp.name;
                    gp.needs_unsafe = true;
                }
                else
                {
                    // Unknown — treat as int
                    gp.go_type = "int";
                    gp.cgo_expr = "C.int(" + gp.name + ")";
                }
            }

            result.push_back(std::move(gp));
            return result;
        }

        // Get Go return type string for a function declaration.
        std::string GoReturnType(const FunctionDecl& f, const std::string& goClassName)
        {
            // True constructors (no self param) return *ClassName
            if (f.is_constructor && !f.has_self)
                return "*" + goClassName;

            if (f.return_type == "void" || f.return_type.empty())
                return "";

            // TClass(wxString) → string
            if (f.return_macro == "TClass" && f.return_arg == "wxString")
                return "string";

            // TClass(wxFoo) → unsafe.Pointer
            if (f.return_macro == "TClass" || f.return_macro == "TSelf")
                return "unsafe.Pointer";

            // String return types
            if (f.return_type == "TString" || f.return_type == "TStringOut" ||
                f.return_type == "TChar")
                return "string";

            if (f.return_type == "TBool")
                return "bool";
            if (f.return_type == "int" || f.return_type == "long" || f.return_type == "TArrayLen" ||
                f.return_type == "TByteStringLen" || f.return_type == "size_t" ||
                f.return_type == "time_t")
                return "int";
            if (f.return_type == "unsigned" || f.return_type == "unsigned int" ||
                f.return_type == "wxUIntPtr" || f.return_type == "unsigned long")
                return "uint";
            if (f.return_type == "double")
                return "float64";
            if (f.return_type == "float")
                return "float32";
            if (f.return_type == "TUInt8")
                return "uint8";
            if (f.return_type == "void*")
                return "unsafe.Pointer";

            // Fallback — if it has pointer, use unsafe.Pointer
            if (f.return_type.find('*') != std::string::npos)
                return "unsafe.Pointer";

            return "int";
        }

        // Check if a return type needs the "unsafe" import
        bool ReturnNeedsUnsafe(const FunctionDecl& f)
        {
            if (f.return_macro == "TClass" || f.return_macro == "TSelf")
                return true;
            if (f.return_type == "void*")
                return true;
            if (f.return_type.find('*') != std::string::npos)
                return true;
            return false;
        }

        // Check if any method in the class needs the "unsafe" import
        bool ClassNeedsUnsafe(const ClassInfo& cls)
        {
            // Constructors always need unsafe (they create a pointer)
            for (auto& m: cls.methods)
            {
                if (m.is_constructor)
                    return true;
                if (ReturnNeedsUnsafe(m))
                    return true;
                for (auto& p: m.params)
                {
                    if (p.macro_name == "TSelf")
                        continue;
                    auto gps = ConvertParam(p);
                    for (auto& gp: gps)
                    {
                        if (gp.needs_unsafe)
                            return true;
                    }
                }
            }
            return false;
        }

        // Build the C call expression for a function.
        // Returns the full C.wxClassName_MethodName(args...) expression.
        std::string BuildCCall(const FunctionDecl& f, const std::string& receiverExpr,
                               const std::vector<std::vector<GoParam>>& paramGroups)
        {
            std::string call = "C." + f.class_name + "_" + f.method_name + "(";
            bool first = true;

            // If has_self, the receiver is the first arg
            if (f.has_self)
            {
                call += receiverExpr;
                first = false;
            }

            // Add converted parameters
            for (auto& group: paramGroups)
            {
                for (auto& gp: group)
                {
                    if (!first)
                        call += ", ";
                    call += gp.cgo_expr;
                    first = false;
                }
            }

            call += ")";
            return call;
        }

        // Build a disambiguated Go constructor name from the C method name.
        // "Create" → "New" + goClassName, e.g. "NewBitmap"
        // "CreateEmpty" → "New" + goClassName + "Empty", e.g. "NewBitmapEmpty"
        // "CreateFromData" → "New" + goClassName + "FromData", e.g. "NewBitmapFromData"
        std::string GoConstructorName(const std::string& goClassName, const std::string& methodName)
        {
            std::string suffix;
            if (methodName.size() > 6 && methodName.substr(0, 6) == "Create")
                suffix = methodName.substr(6);  // e.g., "Empty", "FromData", "Load"
            // "Create" alone → empty suffix
            return "New" + goClassName + suffix;
        }

        // Emit a constructor function: NewClassName(...) or NewClassNameSuffix(...)
        void EmitConstructor(std::ostream& out, const ClassInfo& cls, const FunctionDecl& f,
                             const std::string& goClassName, bool isWindowDerived)
        {
            // Collect Go params (excluding TSelf since constructors typically don't have it)
            std::vector<std::vector<GoParam>> paramGroups;
            for (auto& p: f.params)
            {
                if (p.macro_name == "TSelf")
                    continue;
                paramGroups.push_back(ConvertParam(p));
            }

            // Function signature — disambiguate overloaded Create* methods
            std::string funcName = GoConstructorName(goClassName, f.method_name);
            out << "func " << funcName << "(";
            bool first = true;
            for (auto& group: paramGroups)
            {
                for (auto& gp: group)
                {
                    if (!first)
                        out << ", ";
                    out << gp.name << " " << gp.go_type;
                    first = false;
                }
            }
            out << ") *" << goClassName << " {\n";

            // Pre-call statements (e.g., NewWxString)
            for (auto& group: paramGroups)
            {
                for (auto& gp: group)
                {
                    if (!gp.pre_call.empty())
                        out << "\t" << gp.pre_call << "\n";
                    if (!gp.defer_call.empty())
                        out << "\t" << gp.defer_call << "\n";
                }
            }

            // C call
            std::string cCall = BuildCCall(f, "", paramGroups);
            out << "\tptr := " << cCall << "\n";

            // Nil check
            out << "\tif ptr == nil {\n";
            out << "\t\treturn nil\n";
            out << "\t}\n";

            // Create and return Go object
            out << "\tobj := &" << goClassName << "{}\n";
            out << "\tobj.SetPtr(unsafe.Pointer(ptr))\n";
            out << "\treturn obj\n";
            out << "}\n\n";
        }

        // Emit a method: func (recv *ClassName) MethodName(...)
        void EmitMethod(std::ostream& out, const ClassInfo& cls, const FunctionDecl& f,
                        const std::string& goClassName)
        {
            std::string recv = ReceiverVar(goClassName);
            std::string goRetType = GoReturnType(f, goClassName);
            bool isWindowDerived = cls.is_window_derived;

            // Collect non-self Go params
            std::vector<std::vector<GoParam>> paramGroups;
            for (auto& p: f.params)
            {
                if (p.macro_name == "TSelf")
                    continue;
                paramGroups.push_back(ConvertParam(p));
            }

            // Method signature
            out << "func (" << recv << " *" << goClassName << ") "
                << SafeGoIdentifier(f.method_name)
                << "(";  // SafeGoIdentifier: prefix names starting with a digit
            bool first = true;
            for (auto& group: paramGroups)
            {
                for (auto& gp: group)
                {
                    if (!first)
                        out << ", ";
                    out << gp.name << " " << gp.go_type;
                    first = false;
                }
            }
            out << ")";
            if (!goRetType.empty())
                out << " " << goRetType;
            out << " {\n";

            // Pre-call statements
            for (auto& group: paramGroups)
            {
                for (auto& gp: group)
                {
                    if (!gp.pre_call.empty())
                        out << "\t" << gp.pre_call << "\n";
                    if (!gp.defer_call.empty())
                        out << "\t" << gp.defer_call << "\n";
                }
            }

            // Receiver expression for C call
            std::string recvExpr = recv + ".Ptr()";

            // C call
            std::string cCall = BuildCCall(f, recvExpr, paramGroups);

            // Handle return type
            if (goRetType.empty())
            {
                // void return
                out << "\t" << cCall << "\n";
            }
            else if (goRetType == "bool")
            {
                out << "\treturn " << cCall << " != 0\n";
            }
            else if (goRetType == "string")
            {
                // String return: call, convert, free
                out << "\twxStr := " << cCall << "\n";
                out << "\treturn WxStringToGoAndFree(wxStr)\n";
            }
            else if (goRetType == "int")
            {
                out << "\treturn int(" << cCall << ")\n";
            }
            else if (goRetType == "uint")
            {
                out << "\treturn uint(" << cCall << ")\n";
            }
            else if (goRetType == "float64")
            {
                out << "\treturn float64(" << cCall << ")\n";
            }
            else if (goRetType == "float32")
            {
                out << "\treturn float32(" << cCall << ")\n";
            }
            else if (goRetType == "uint8")
            {
                out << "\treturn uint8(" << cCall << ")\n";
            }
            else if (goRetType == "unsafe.Pointer")
            {
                out << "\treturn unsafe.Pointer(" << cCall << ")\n";
            }
            else
            {
                // Fallback
                out << "\treturn " << cCall << "\n";
            }

            out << "}\n\n";
        }

        // Check if a function declaration looks valid for code generation
        // (skip malformed or comment-contaminated declarations)
        bool IsValidFunction(const FunctionDecl& f)
        {
            // Skip methods with comment artifacts in return type or method name
            if (f.return_type.find("//") != std::string::npos ||
                f.return_type.find("/*") != std::string::npos ||
                f.return_type.find("*/") != std::string::npos)
                return false;
            if (f.method_name.find("//") != std::string::npos ||
                f.method_name.find("/*") != std::string::npos)
                return false;
            if (f.method_name.empty())
                return false;

            // Skip methods with comment artifacts in params
            for (auto& p: f.params)
            {
                if (p.raw_type.find("//") != std::string::npos ||
                    p.raw_type.find("/*") != std::string::npos)
                    return false;
            }

            return true;
        }

    }  // anonymous namespace

    // -------------------------------------------------------------------------
    // GoEmitter public interface
    // -------------------------------------------------------------------------

    void GoEmitter::Generate(const ParsedFFI& ffi, const fs::path& outDir)
    {
        fs::create_directories(outDir);

        GenerateHelpers(outDir);
        GenerateConstants(ffi, outDir);
        GenerateEvents(ffi, outDir);
        GenerateKeys(ffi, outDir);
        GenerateClassFiles(ffi, outDir);

        std::cerr << "Go: checked " << (4 + ffi.classes.size()) << " files in " << outDir << "\n";
    }

    VerifyResult GoEmitter::Verify(const ParsedFFI& /* ffi */, const fs::path& /* dir */)
    {
        VerifyResult result;
        result.success = false;
        result.messages.push_back("Go verify: use 'kwxgen verify' command instead");
        return result;
    }

    // -------------------------------------------------------------------------
    // helpers_gen.go — utility functions used by generated code
    // -------------------------------------------------------------------------

    void GoEmitter::GenerateHelpers(const fs::path& outDir)
    {
        auto path = outDir / "helpers_gen.go";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "package wx\n\n";

        out << "// #include \"kwx_classes.h\"\n";
        out << "import \"C\"\n\n";

        out << "// boolToInt converts a Go bool to C.int for use in CGo calls.\n";
        out << "func boolToInt(b bool) C.int {\n";
        out << "\tif b {\n";
        out << "\t\treturn 1\n";
        out << "\t}\n";
        out << "\treturn 0\n";
        out << "}\n";

        out.Flush();
        std::cerr << "  helpers_gen.go:   utility functions";
        if (!out.WasWritten())
            std::cerr << " (unchanged)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // constants_gen.go
    // -------------------------------------------------------------------------

    void GoEmitter::GenerateConstants(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "constants_gen.go";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "package wx\n\n";

        // CGo preamble — include kwx_constants.h for WXFFI_EXPORT declarations,
        // then emit extern declarations for all constants from kwx_defs.cpp
        // (those functions are defined in the .cpp but not declared in any header).
        bool needsUnsafe = ConstantsNeedUnsafe(ffi.constants);
        out << "/*\n";
        out << "#include \"kwx_constants.h\"\n";
        out << "\n";
        for (const auto& c: ffi.constants)
        {
            if (c.return_type == "int")
                out << "extern int " << c.export_name << "(void);\n";
            else
                out << "extern void* " << c.export_name << "(void);\n";
        }
        out << "*/\n";
        out << "import \"C\"\n";

        if (needsUnsafe)
        {
            out << "\nimport \"unsafe\"\n";
        }

        out << "\n";

        // Sort constants by name for stable output
        auto sorted = ffi.constants;
        std::sort(sorted.begin(), sorted.end(),
                  [](const ConstantDecl& a, const ConstantDecl& b)
                  {
                      return a.constant_name < b.constant_name;
                  });

        // Emit constants grouped by type
        // First: int constants (the vast majority)
        out << "// Integer constants\n";
        out << "var (\n";
        for (const auto& c: sorted)
        {
            if (c.return_type == "int")
            {
                out << "\t" << c.constant_name << " = " << GoConstantExpr(c) << "\n";
            }
        }
        out << ")\n";

        // Then: pointer constants (wxString*, const wxColour*, etc.)
        bool hasPointerConsts = false;
        for (const auto& c: sorted)
        {
            if (c.return_type != "int")
            {
                if (!hasPointerConsts)
                {
                    out << "\n// Pointer constants\n";
                    out << "var (\n";
                    hasPointerConsts = true;
                }
                out << "\t" << c.constant_name << " = " << GoConstantExpr(c) << "\n";
            }
        }
        if (hasPointerConsts)
        {
            out << ")\n";
        }

        out.Flush();
        std::cerr << "  constants_gen.go: " << ffi.constants.size() << " constants";
        if (!out.WasWritten())
            std::cerr << " (unchanged)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // events_gen.go
    // -------------------------------------------------------------------------

    void GoEmitter::GenerateEvents(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "events_gen.go";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "package wx\n\n";

        // CGo preamble
        out << "// #include \"kwx_events.h\"\n";
        out << "import \"C\"\n\n";

        // Sort events by name for stable output
        auto sorted = ffi.events;
        std::sort(sorted.begin(), sorted.end(),
                  [](const EventDecl& a, const EventDecl& b)
                  {
                      return a.event_name < b.event_name;
                  });

        out << "var (\n";
        for (const auto& e: sorted)
        {
            out << "\t" << e.event_name << " = int(C." << e.export_name << "())\n";
        }
        out << ")\n";

        out.Flush();
        std::cerr << "  events_gen.go:    " << ffi.events.size() << " events";
        if (!out.WasWritten())
            std::cerr << " (unchanged)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // keys_gen.go
    // -------------------------------------------------------------------------

    void GoEmitter::GenerateKeys(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "keys_gen.go";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "package wx\n\n";

        // CGo preamble
        out << "// #include \"kwx_keys.h\"\n";
        out << "import \"C\"\n\n";

        // Sort keys by name for stable output
        auto sorted = ffi.keys;
        std::sort(sorted.begin(), sorted.end(),
                  [](const KeyDecl& a, const KeyDecl& b)
                  {
                      return a.key_name < b.key_name;
                  });

        out << "var (\n";
        for (const auto& k: sorted)
        {
            out << "\t" << k.key_name << " = int(C." << k.export_name << "())\n";
        }
        out << ")\n";

        out.Flush();
        std::cerr << "  keys_gen.go:      " << ffi.keys.size() << " keys";
        if (!out.WasWritten())
            std::cerr << " (unchanged)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // Class files: one file per class
    // -------------------------------------------------------------------------

    void GoEmitter::GenerateClassFiles(const ParsedFFI& ffi, const fs::path& outDir)
    {
        size_t fileCount = 0;
        size_t writtenCount = 0;
        size_t methodCount = 0;
        size_t skippedMethods = 0;

        for (auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;

            auto fileName = GoFileName(cls.name);
            auto path = outDir / fileName;
            ConditionalFileWriter out(path);
            if (!out.is_open())
            {
                std::cerr << "Error: cannot create " << path << "\n";
                continue;
            }

            EmitClassFile(out, cls, ffi);
            if (out.Flush())
                ++writtenCount;
            ++fileCount;

            for (auto& m: cls.methods)
            {
                if (IsValidFunction(m))
                    ++methodCount;
                else
                    ++skippedMethods;
            }
        }

        std::cerr << "  class files:      " << fileCount << " files, " << methodCount << " methods";
        if (skippedMethods > 0)
            std::cerr << " (" << skippedMethods << " skipped)";
        std::cerr << " [" << writtenCount << " written, " << (fileCount - writtenCount)
                  << " unchanged]";
        std::cerr << "\n";
    }

    void GoEmitter::EmitClassFile(std::ostream& out, const ClassInfo& cls, const ParsedFFI& ffi)
    {
        std::string goClassName = StripPrefix(cls.name);
        bool isWindowDerived = cls.is_window_derived;
        bool needsUnsafe = ClassNeedsUnsafe(cls);

        // Header
        WriteGeneratedHeader(out);
        out << "package wx\n\n";

        // CGo preamble
        out << "// #include \"kwx_classes.h\"\n";
        out << "import \"C\"\n";

        if (needsUnsafe)
        {
            out << "import \"unsafe\"\n";
        }

        out << "\n";

        // Type definition — embed parent type from class hierarchy
        if (isWindowDerived)
        {
            out << "type " << goClassName << " struct{ BaseWindow }\n\n";
        }
        else
        {
            // Determine the Go embedded type from the parent class.
            // If parent is known and wrapped, embed it; otherwise fall back to BaseObject.
            std::string embedType = "BaseObject";
            if (!cls.parent.empty())
            {
                std::string goParent = StripPrefix(cls.parent);
                // Check the parent is a real wrapped class (exists in ffi.classes)
                bool parentWrapped = std::any_of(ffi.classes.begin(), ffi.classes.end(),
                                                 [&](const ClassInfo& c)
                                                 {
                                                     return c.name == cls.parent;
                                                 });
                if (parentWrapped)
                    embedType = goParent;
            }
            out << "type " << goClassName << " struct{ " << embedType << " }\n\n";
        }

        // Emit methods
        for (auto& f: cls.methods)
        {
            if (!IsValidFunction(f))
                continue;

            // True constructors: is_constructor && no self param
            // Methods like CreateStatusBar have is_constructor but also has_self,
            // so they're regular methods.
            bool isTrueConstructor = f.is_constructor && !f.has_self;

            if (isTrueConstructor)
            {
                EmitConstructor(out, cls, f, goClassName, isWindowDerived);
            }
            else if (f.is_destructor)
            {
                // Delete method
                std::string recv = ReceiverVar(goClassName);
                out << "func (" << recv << " *" << goClassName << ") Delete() {\n";
                out << "\tC." << f.class_name << "_Delete(" << recv << ".Ptr())\n";
                out << "}\n\n";
            }
            else
            {
                EmitMethod(out, cls, f, goClassName);
            }
        }
    }

}  // namespace kwxgen
