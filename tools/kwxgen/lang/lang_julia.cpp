// Generated by GitHub Copilot. Directed and reviewed by Ralph Walden.
// Licensed under Apache 2.0. This file is not subject to copyright.

#include "lang_julia.h"

#include "julia_type_map.h"

#include "file_writer.h"
#include <algorithm>
#include <filesystem>
#include <iostream>
#include <sstream>
#include <vector>

namespace fs = std::filesystem;

namespace kwxgen
{

    namespace
    {

        void WriteGeneratedHeader(std::ostream& out)
        {
            out << "# Code generated by kwxgen. DO NOT EDIT.\n\n";
        }

        // Build a C function name from a FunctionDecl.
        std::string CFuncName(const FunctionDecl& f)
        {
            if (f.class_name.empty())
                return f.method_name;
            return f.class_name + "_" + f.method_name;
        }

        // Emit a Julia ccall wrapper for a function.
        // Output format:
        //   function name(param::Type, ...)
        //       ccall((:c_name, libkwxFFI), RetType, (ParamTypes...), params...)
        //   end
        void EmitCCallWrapper(std::ostream& out, const std::string& juliaName,
                              const std::string& cName, const std::string& returnType,
                              const std::vector<JuliaParam>& params)
        {
            if (params.empty())
            {
                // Zero-argument function: use compact form
                out << juliaName << "() = ccall((:" << cName << ", libkwxFFI), " << returnType
                    << ", ())\n";
                return;
            }

            // Multi-argument function
            out << "function " << juliaName << "(";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << params[i].name << "::" << params[i].julia_type;
            }
            out << ")\n";

            // ccall line
            out << "    ccall((:" << cName << ", libkwxFFI), " << returnType << ",\n";

            // Type tuple
            out << "        (";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << params[i].julia_type;
            }
            // Julia requires trailing comma for single-element tuples
            if (params.size() == 1)
                out << ",";
            out << "),\n";

            // Argument names
            out << "        ";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << params[i].name;
            }
            out << ")\n";

            out << "end\n";
        }

        // Emit a ccall wrapper from a FunctionDecl.
        void EmitFunctionWrapper(std::ostream& out, const FunctionDecl& f)
        {
            std::string cName = CFuncName(f);
            std::string retType = JuliaReturnType(f.return_type, f.return_macro);

            std::vector<JuliaParam> jParams;
            for (const auto& p: f.params)
            {
                auto expanded = ExpandParamToJulia(p);
                for (auto& jp: expanded)
                    jParams.push_back(std::move(jp));
            }

            EmitCCallWrapper(out, cName, cName, retType, jParams);
        }

        // Check if a function declaration looks valid (skip malformed ones).
        bool IsValidFunction(const FunctionDecl& f)
        {
            if (f.return_type.find("//") != std::string::npos ||
                f.return_type.find("/*") != std::string::npos ||
                f.return_type.find("*/") != std::string::npos)
                return false;
            if (f.method_name.find("//") != std::string::npos ||
                f.method_name.find("/*") != std::string::npos)
                return false;
            if (f.method_name.empty())
                return false;
            for (const auto& p: f.params)
            {
                if (p.raw_type.find("//") != std::string::npos ||
                    p.raw_type.find("/*") != std::string::npos)
                    return false;
            }
            return true;
        }

    }  // anonymous namespace

    // -------------------------------------------------------------------------
    // JuliaEmitter public interface
    // -------------------------------------------------------------------------

    void JuliaEmitter::Generate(const ParsedFFI& ffi, const fs::path& outDir)
    {
        fs::create_directories(outDir);

        GenerateEvents(ffi, outDir);
        GenerateKeys(ffi, outDir);
        GenerateConstants(ffi, outDir);
        GenerateClasses(ffi, outDir);
        GenerateFreeFunctions(ffi, outDir);
        GenerateModule(outDir);

        std::cerr << "Julia: generated 6 files in " << outDir << "\n";
    }

    VerifyResult JuliaEmitter::Verify(const ParsedFFI& /* ffi */, const fs::path& /* dir */)
    {
        VerifyResult result;
        result.success = false;
        result.messages.push_back("Julia verify: use 'kwxgen verify' command instead");
        return result;
    }

    // -------------------------------------------------------------------------
    // events_gen.jl
    // -------------------------------------------------------------------------

    void JuliaEmitter::GenerateEvents(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "events_gen.jl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);

        auto sorted = ffi.events;
        std::sort(sorted.begin(), sorted.end(),
                  [](const EventDecl& a, const EventDecl& b)
                  {
                      return a.event_name < b.event_name;
                  });

        for (const auto& e: sorted)
        {
            out << e.event_name << "() = ccall((:" << e.export_name << ", libkwxFFI), Cint, ())\n";
        }

        std::cerr << "  events_gen.jl:       " << ffi.events.size() << " events\n";
    }

    // -------------------------------------------------------------------------
    // keys_gen.jl
    // -------------------------------------------------------------------------

    void JuliaEmitter::GenerateKeys(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "keys_gen.jl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);

        auto sorted = ffi.keys;
        std::sort(sorted.begin(), sorted.end(),
                  [](const KeyDecl& a, const KeyDecl& b)
                  {
                      return a.key_name < b.key_name;
                  });

        for (const auto& k: sorted)
        {
            out << k.key_name << "() = ccall((:" << k.export_name << ", libkwxFFI), Cint, ())\n";
        }

        std::cerr << "  keys_gen.jl:         " << ffi.keys.size() << " keys\n";
    }

    // -------------------------------------------------------------------------
    // constants_gen.jl
    // -------------------------------------------------------------------------

    void JuliaEmitter::GenerateConstants(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "constants_gen.jl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);

        auto sorted = ffi.constants;
        std::sort(sorted.begin(), sorted.end(),
                  [](const ConstantDecl& a, const ConstantDecl& b)
                  {
                      return a.export_name < b.export_name;
                  });

        for (const auto& c: sorted)
        {
            std::string retType;
            if (c.return_type.find('*') != std::string::npos)
                retType = "Ptr{Cvoid}";
            else if (c.return_type == "int")
                retType = "Cint";
            else
                retType = "Cint";  // fallback

            out << c.constant_name << "() = ccall((:" << c.export_name << ", libkwxFFI), "
                << retType << ", ())\n";
        }

        std::cerr << "  constants_gen.jl:    " << ffi.constants.size() << " constants\n";
    }

    // -------------------------------------------------------------------------
    // classes_gen.jl
    // -------------------------------------------------------------------------

    void JuliaEmitter::GenerateClasses(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "classes_gen.jl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);

        size_t methodCount = 0;
        size_t skippedCount = 0;

        for (const auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;

            out << "# " << cls.name << "\n";

            for (const auto& f: cls.methods)
            {
                if (!IsValidFunction(f))
                {
                    ++skippedCount;
                    continue;
                }
                EmitFunctionWrapper(out, f);
                ++methodCount;
            }

            out << "\n";
        }

        std::cerr << "  classes_gen.jl:      " << methodCount << " methods";
        if (skippedCount > 0)
            std::cerr << " (" << skippedCount << " skipped)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // freefuncs_gen.jl
    // -------------------------------------------------------------------------

    void JuliaEmitter::GenerateFreeFunctions(const ParsedFFI& ffi, const fs::path& outDir)
    {
        if (ffi.free_functions.empty())
            return;

        auto path = outDir / "freefuncs_gen.jl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);

        size_t count = 0;
        for (const auto& f: ffi.free_functions)
        {
            if (!IsValidFunction(f))
                continue;
            EmitFunctionWrapper(out, f);
            ++count;
        }

        std::cerr << "  freefuncs_gen.jl:    " << count << " free functions\n";
    }

    // -------------------------------------------------------------------------
    // KwxFFI_gen.jl â€” Julia module that includes all generated files
    // -------------------------------------------------------------------------

    void JuliaEmitter::GenerateModule(const fs::path& outDir)
    {
        auto path = outDir / "KwxFFI_gen.jl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "module KwxFFI\n\n";
        out << "const libkwxFFI = \"kwxFFI\"\n\n";
        out << "include(\"events_gen.jl\")\n";
        out << "include(\"keys_gen.jl\")\n";
        out << "include(\"constants_gen.jl\")\n";
        out << "include(\"classes_gen.jl\")\n";
        out << "include(\"freefuncs_gen.jl\")\n";
        out << "\nend # module KwxFFI\n";

        std::cerr << "  KwxFFI_gen.jl:       module definition\n";
    }

}  // namespace kwxgen
