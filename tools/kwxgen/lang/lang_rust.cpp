// Generated by GitHub Copilot. Directed and reviewed by Ralph Walden.
// Licensed under Apache 2.0. This file is not subject to copyright.

#include "lang_rust.h"

#include "rust_type_map.h"

#include "file_writer.h"
#include <algorithm>
#include <cctype>
#include <filesystem>
#include <iostream>
#include <set>
#include <vector>

namespace fs = std::filesystem;

namespace kwxgen
{

    namespace
    {

        void WriteGeneratedHeader(std::ostream& out)
        {
            out << "// Code generated by kwxgen. DO NOT EDIT.\n\n";
        }

        // Build a C function name from a FunctionDecl.
        std::string CFuncName(const FunctionDecl& f)
        {
            if (f.class_name.empty())
                return f.method_name;
            return f.class_name + "_" + f.method_name;
        }

        // Strip wx/kwx/ELJ prefix: "wxButton" → "Button"
        std::string StripPrefix(const std::string& name)
        {
            if (name.size() > 2 && name[0] == 'w' && name[1] == 'x' && std::isupper(name[2]))
                return name.substr(2);
            if (name.size() > 3 && name.substr(0, 3) == "kwx" && std::isupper(name[3]))
                return name.substr(3);
            if (name.size() > 3 && name.substr(0, 3) == "ELJ" && std::isupper(name[3]))
                return name.substr(3);
            return name;
        }

        // Convert CamelCase to snake_case: "SetDefault" → "set_default"
        std::string ToSnakeCase(const std::string& name)
        {
            std::string result;
            for (size_t i = 0; i < name.size(); ++i)
            {
                char ch = name[i];
                if (std::isupper(static_cast<unsigned char>(ch)))
                {
                    if (i > 0)
                    {
                        // Insert underscore before uppercase if preceded by lowercase
                        // or if followed by lowercase (handles acronyms like "HTML")
                        char prev = name[i - 1];
                        bool prevLower = std::islower(static_cast<unsigned char>(prev));
                        bool nextLower = (i + 1 < name.size()) &&
                                         std::islower(static_cast<unsigned char>(name[i + 1]));
                        if (prevLower ||
                            (std::isupper(static_cast<unsigned char>(prev)) && nextLower))
                            result += '_';
                    }
                    result += static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));
                }
                else
                {
                    result += ch;
                }
            }
            return result;
        }

        // Convert a method name to a safe Rust method name (snake_case, keyword-escaped).
        std::string RustSafeMethodName(const std::string& methodName)
        {
            std::string snake = ToSnakeCase(methodName);
            // Check for Rust keywords
            if (snake == "move" || snake == "break" || snake == "continue" || snake == "return" ||
                snake == "type" || snake == "self" || snake == "super" || snake == "crate" ||
                snake == "match" || snake == "ref" || snake == "mod" || snake == "use" ||
                snake == "fn" || snake == "let" || snake == "mut" || snake == "pub" ||
                snake == "if" || snake == "else" || snake == "for" || snake == "while" ||
                snake == "loop" || snake == "in" || snake == "as" || snake == "impl" ||
                snake == "trait" || snake == "struct" || snake == "enum" || snake == "union" ||
                snake == "const" || snake == "static" || snake == "extern" || snake == "unsafe" ||
                snake == "async" || snake == "await" || snake == "dyn" || snake == "where" ||
                snake == "yield" || snake == "box" || snake == "macro" || snake == "true" ||
                snake == "false" || snake == "abstract" || snake == "become" || snake == "do" ||
                snake == "final" || snake == "override" || snake == "priv" || snake == "try" ||
                snake == "typeof" || snake == "unsized" || snake == "virtual")
            {
                return snake + "_";
            }
            // Identifiers starting with a digit are invalid in Rust
            if (!snake.empty() && std::isdigit(static_cast<unsigned char>(snake[0])))
                return "_" + snake;
            return snake;
        }

        // Lowercase a string entirely.
        std::string ToLower(const std::string& s)
        {
            std::string result;
            result.reserve(s.size());
            for (char c: s)
                result += static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
            return result;
        }

        // Rust module name from class name: "wxButton" → "button"
        std::string RustModuleName(const std::string& className)
        {
            return ToSnakeCase(StripPrefix(className));
        }

        // Rust file name from class name: "wxButton" → "button.rs"
        std::string RustFileName(const std::string& className)
        {
            return RustModuleName(className) + ".rs";
        }

        // Emit a single extern "C" declaration for sys.rs.
        void EmitExternDecl(std::ostream& out, const std::string& funcName,
                            const std::string& returnType, const std::vector<RustFFIParam>& params)
        {
            out << "    pub fn " << funcName << "(";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << params[i].name << ": " << params[i].rust_type;
            }
            out << ")";
            if (!returnType.empty())
                out << " -> " << returnType;
            out << ";\n";
        }

        // Emit an extern "C" declaration from a FunctionDecl.
        void EmitFunctionExternDecl(std::ostream& out, const FunctionDecl& f)
        {
            std::string retType = RustFFIReturnType(f.return_type, f.return_macro);
            std::string funcName = CFuncName(f);

            std::vector<RustFFIParam> params;
            for (const auto& p: f.params)
            {
                auto expanded = ExpandParamToRustFFI(p);
                for (auto& rp: expanded)
                    params.push_back(std::move(rp));
            }

            EmitExternDecl(out, funcName, retType, params);
        }

        // Check if a function declaration looks valid (skip malformed ones).
        bool IsValidFunction(const FunctionDecl& f)
        {
            if (f.return_type.find("//") != std::string::npos ||
                f.return_type.find("/*") != std::string::npos ||
                f.return_type.find("*/") != std::string::npos)
                return false;
            if (f.method_name.find("//") != std::string::npos ||
                f.method_name.find("/*") != std::string::npos)
                return false;
            if (f.method_name.empty())
                return false;
            for (const auto& p: f.params)
            {
                if (p.raw_type.find("//") != std::string::npos ||
                    p.raw_type.find("/*") != std::string::npos)
                    return false;
            }
            return true;
        }

        // A true destructor takes only self as its parameter.
        bool IsDestructor(const FunctionDecl& f)
        {
            return f.is_destructor && f.params.size() == 1;
        }

        // Check if a class has a Delete method (for Drop implementation).
        bool HasDeleteMethod(const ClassInfo& cls)
        {
            return std::any_of(cls.methods.begin(), cls.methods.end(), IsDestructor);
        }

        // Determine the safe Rust return type for a method.
        std::string RustSafeReturnType(const FunctionDecl& f, const std::string& rustClassName)
        {
            if (f.return_type == "void" || f.return_type.empty())
                return "";
            if (f.return_macro == "TClass" || f.return_macro == "TSelf" ||
                f.return_macro == "TClassRef")
                return "*mut c_void";
            if (f.return_type == "TBool" || f.return_type == "TBoolInt")
                return "bool";
            if (f.return_type == "TString" || f.return_type == "TStringOut" ||
                f.return_type == "TStringVoid")
                return "*mut c_void";
            if (f.return_type == "int" || f.return_type == "TArrayLen" ||
                f.return_type == "TByteStringLen")
                return "i32";
            if (f.return_type == "long" || f.return_type == "time_t")
                return "i64";
            if (f.return_type == "unsigned" || f.return_type == "unsigned int")
                return "u32";
            if (f.return_type == "unsigned long" || f.return_type == "wxUIntPtr")
                return "u64";
            if (f.return_type == "uintptr_t")
                return "usize";
            if (f.return_type == "double")
                return "f64";
            if (f.return_type == "float")
                return "f32";
            if (f.return_type == "TChar")
                return "u8";
            if (f.return_type == "TUInt8")
                return "u8";
            if (f.return_type == "size_t")
                return "usize";
            if (f.return_type == "void*")
                return "*mut c_void";
            if (f.return_type.find('*') != std::string::npos)
                return "*mut c_void";

            return "i32";
        }

        // Generate the conversion expression wrapping a raw FFI return value to safe Rust type.
        // `call_expr` is the unsafe FFI call expression.
        std::string WrapReturnExpr(const FunctionDecl& f, const std::string& callExpr)
        {
            std::string safeType = RustSafeReturnType(f, "");

            if (safeType.empty())
                return callExpr;  // void
            if (safeType == "bool")
                return callExpr + " != 0";
            if (safeType == "i32")
                return callExpr + " as i32";
            if (safeType == "i64")
                return callExpr + " as i64";
            if (safeType == "u32")
                return callExpr + " as u32";
            if (safeType == "u64")
                return callExpr + " as u64";
            if (safeType == "f64")
                return callExpr + " as f64";
            if (safeType == "f32")
                return callExpr + " as f32";
            if (safeType == "u8")
                return callExpr + " as u8";
            if (safeType == "usize")
                return callExpr + " as usize";

            // Pointers pass through
            return callExpr;
        }

        // Info about a safe Rust parameter in a method signature.
        struct RustSafeParam
        {
            std::string name;
            std::string safe_type;  // Safe Rust type for the method signature
            std::string ffi_expr;   // Expression to convert and pass to the FFI call
        };

        // Convert one Param to safe Rust parameters (for method wrappers).
        std::vector<RustSafeParam> ConvertParamToSafe(const Param& p)
        {
            std::vector<RustSafeParam> result;

            // TSelf as a non-receiver parameter — treat as opaque pointer
            if (p.macro_name == "TSelf")
            {
                RustSafeParam sp;
                sp.name = RustEscapeName(p.param_name.empty() ? "arg" : p.param_name);
                sp.safe_type = "*mut c_void";
                sp.ffi_expr = sp.name;
                result.push_back(std::move(sp));
                return result;
            }

            // Expanded geometry types: individual i32 params
            if (p.macro_name == "TPoint" || p.macro_name == "TSize" || p.macro_name == "TRect" ||
                p.macro_name == "TVector")
            {
                for (auto& n: RustSplitMacroArg(p.macro_arg))
                {
                    std::string name = RustEscapeName(n);
                    result.push_back({ name, "i32", name + " as c_int" });
                }
                return result;
            }

            if (p.macro_name == "TPointLong" || p.macro_name == "TSizeLong" ||
                p.macro_name == "TRectLong" || p.macro_name == "TVectorLong")
            {
                for (auto& n: RustSplitMacroArg(p.macro_arg))
                {
                    std::string name = RustEscapeName(n);
                    result.push_back({ name, "i64", name + " as c_long" });
                }
                return result;
            }

            // Output geometry — pass through as raw pointers
            if (p.macro_name == "TPointOut" || p.macro_name == "TSizeOut" ||
                p.macro_name == "TRectOut" || p.macro_name == "TVectorOut")
            {
                for (auto& n: RustSplitMacroArg(p.macro_arg))
                {
                    std::string name = RustEscapeName(n);
                    result.push_back({ name, "*mut i32", name + " as *mut c_int" });
                }
                return result;
            }

            if (p.macro_name == "TPointOutVoid" || p.macro_name == "TSizeOutVoid" ||
                p.macro_name == "TRectOutVoid" || p.macro_name == "TVectorOutVoid")
            {
                for (auto& n: RustSplitMacroArg(p.macro_arg))
                {
                    std::string name = RustEscapeName(n);
                    result.push_back({ name, "*mut c_void", name });
                }
                return result;
            }

            if (p.macro_name == "TSizeOutDouble")
            {
                for (auto& n: RustSplitMacroArg(p.macro_arg))
                {
                    std::string name = RustEscapeName(n);
                    result.push_back({ name, "*mut f64", name + " as *mut c_double" });
                }
                return result;
            }

            if (p.macro_name == "TColorRGB")
            {
                for (auto& n: RustSplitMacroArg(p.macro_arg))
                {
                    std::string name = RustEscapeName(n);
                    result.push_back({ name, "u8", name });
                }
                return result;
            }

            // Array types
            if (p.macro_name == "TArrayString" || p.macro_name == "TArrayInt" ||
                p.macro_name == "TByteString" || p.macro_name == "TByteStringLazy")
            {
                auto names = RustSplitMacroArg(p.macro_arg);
                if (names.size() >= 2)
                {
                    std::string n0 = RustEscapeName(names[0]);
                    std::string n1 = RustEscapeName(names[1]);
                    result.push_back({ n0, "i32", n0 + " as c_int" });
                    result.push_back({ n1, "*mut c_void", n1 });
                }
                return result;
            }

            if (p.macro_name == "TArrayObjectOutVoid")
            {
                std::string name = RustEscapeName(p.param_name.empty() ? "arr" : p.param_name);
                result.push_back({ name, "*mut c_void", name });
                return result;
            }

            // Single parameter
            RustSafeParam sp;
            sp.name = RustEscapeName(p.param_name.empty() ? "arg" : p.param_name);

            if (p.macro_name == "TClass" || p.macro_name == "TClassRef")
            {
                sp.safe_type = "*mut c_void";
                sp.ffi_expr = sp.name;
            }
            else if (p.macro_name == "TBool" || p.raw_type == "TBool")
            {
                sp.safe_type = "bool";
                sp.ffi_expr = sp.name + " as c_int";
            }
            else if (p.raw_type == "TBoolInt" || p.raw_type == "TBool*")
            {
                sp.safe_type = "i32";
                sp.ffi_expr = sp.name + " as c_int";
            }
            else if (p.macro_name == "TClosureFun" || p.raw_type == "TClosureFun")
            {
                sp.safe_type = "*mut c_void";
                sp.ffi_expr = sp.name;
            }
            else if (p.raw_type == "TStringVoid" || p.macro_name == "TStringVoid")
            {
                sp.safe_type = "*mut c_void";
                sp.ffi_expr = sp.name;
            }
            else if (p.raw_type == "TArrayIntOutVoid" || p.raw_type == "TArrayIntPtrOutVoid" ||
                     p.raw_type == "TArrayStringOutVoid" || p.raw_type == "TByteStringOut" ||
                     p.raw_type == "TByteStringLazyOut" || p.raw_type == "TArrayObjectOutVoid")
            {
                sp.safe_type = "*mut c_void";
                sp.ffi_expr = sp.name;
            }
            else if (p.raw_type == "TChar")
            {
                sp.safe_type = "u8";
                sp.ffi_expr = sp.name + " as c_char";
            }
            else if (p.raw_type == "TUInt8")
            {
                sp.safe_type = "u8";
                sp.ffi_expr = sp.name;
            }
            else
            {
                // Plain C types
                std::string raw = p.raw_type;
                if (raw.empty() || raw == "int")
                {
                    sp.safe_type = "i32";
                    sp.ffi_expr = sp.name + " as c_int";
                }
                else if (raw == "long")
                {
                    sp.safe_type = "i64";
                    sp.ffi_expr = sp.name + " as c_long";
                }
                else if (raw == "unsigned" || raw == "unsigned int")
                {
                    sp.safe_type = "u32";
                    sp.ffi_expr = sp.name + " as c_uint";
                }
                else if (raw == "unsigned long" || raw == "wxUIntPtr")
                {
                    sp.safe_type = "u64";
                    sp.ffi_expr = sp.name + " as c_ulong";
                }
                else if (raw == "uintptr_t")
                {
                    sp.safe_type = "usize";
                    sp.ffi_expr = sp.name + " as usize";
                }
                else if (raw == "double")
                {
                    sp.safe_type = "f64";
                    sp.ffi_expr = sp.name + " as c_double";
                }
                else if (raw == "float")
                {
                    sp.safe_type = "f32";
                    sp.ffi_expr = sp.name + " as c_float";
                }
                else if (raw == "size_t")
                {
                    sp.safe_type = "usize";
                    sp.ffi_expr = sp.name;
                }
                else if (raw.find('*') != std::string::npos)
                {
                    sp.safe_type = "*mut c_void";
                    sp.ffi_expr = sp.name;
                }
                else
                {
                    sp.safe_type = "i32";
                    sp.ffi_expr = sp.name + " as c_int";
                }
            }

            result.push_back(std::move(sp));
            return result;
        }

        // Build the list of trait names a class should implement based on its hierarchy.
        // Returns the chain from the most derived parent to the root.
        std::vector<std::string> BuildTraitChain(const ClassInfo& cls, const ParsedFFI& ffi)
        {
            std::vector<std::string> chain;
            std::string current = cls.parent;
            std::set<std::string> visited;

            while (!current.empty() && visited.find(current) == visited.end())
            {
                visited.insert(current);
                chain.push_back(current);
                auto it = ffi.parent_map.find(current);
                if (it != ffi.parent_map.end())
                    current = it->second;
                else
                    break;
            }

            return chain;
        }

    }  // anonymous namespace

    // -------------------------------------------------------------------------
    // RustEmitter public interface
    // -------------------------------------------------------------------------

    void RustEmitter::Generate(const ParsedFFI& ffi, const fs::path& outDir)
    {
        fs::create_directories(outDir);
        auto srcDir = outDir / "src";
        fs::create_directories(srcDir);

        GenerateCargoToml(outDir);
        GenerateSys(ffi, srcDir);
        GenerateTraits(ffi, srcDir);
        GenerateEvents(ffi, srcDir);
        GenerateKeys(ffi, srcDir);
        GenerateConstants(ffi, srcDir);
        GenerateFreeFunctions(ffi, srcDir);
        GenerateClassFiles(ffi, srcDir);
        GenerateLib(ffi, srcDir);

        std::cerr << "Rust: generated crate in " << outDir << "\n";
    }

    VerifyResult RustEmitter::Verify(const ParsedFFI& /* ffi */, const fs::path& /* dir */)
    {
        VerifyResult result;
        result.success = false;
        result.messages.push_back("Rust verify: use 'kwxgen verify' command instead");
        return result;
    }

    // -------------------------------------------------------------------------
    // Cargo.toml
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateCargoToml(const fs::path& outDir)
    {
        auto path = outDir / "Cargo.toml";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        out << "# Code generated by kwxgen. DO NOT EDIT.\n\n";
        out << "[package]\n";
        out << "name = \"kwxffi-sys\"\n";
        out << "version = \"0.1.0\"\n";
        out << "edition = \"2021\"\n";
        out << "description = \"Raw FFI bindings to kwxFFI (wxWidgets C wrapper)\"\n";
        out << "publish = false\n";
        out << "\n";
        out << "[lib]\n";
        out << "name = \"kwxffi_sys\"\n";
        out << "path = \"src/lib.rs\"\n";

        std::cerr << "  Cargo.toml\n";
    }

    // -------------------------------------------------------------------------
    // src/sys.rs — All extern "C" declarations
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateSys(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        auto path = srcDir / "sys.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "#![allow(non_snake_case)]\n\n";
        out << "use std::os::raw::*;\n\n";

        out << "extern \"C\" {\n";

        // Events
        {
            auto sorted = ffi.events;
            std::sort(sorted.begin(), sorted.end(),
                      [](const EventDecl& a, const EventDecl& b)
                      {
                          return a.event_name < b.event_name;
                      });

            out << "    // Events\n";
            std::string lastEvtExport;
            for (const auto& e: sorted)
            {
                if (e.export_name == lastEvtExport)
                    continue;
                lastEvtExport = e.export_name;
                out << "    pub fn " << e.export_name << "() -> c_int;\n";
            }
            out << "\n";
        }

        // Keys
        {
            auto sorted = ffi.keys;
            std::sort(sorted.begin(), sorted.end(),
                      [](const KeyDecl& a, const KeyDecl& b)
                      {
                          return a.key_name < b.key_name;
                      });

            out << "    // Keys\n";
            for (const auto& k: sorted)
                out << "    pub fn " << k.export_name << "() -> c_int;\n";
            out << "\n";
        }

        // Constants
        {
            auto sorted = ffi.constants;
            std::sort(sorted.begin(), sorted.end(),
                      [](const ConstantDecl& a, const ConstantDecl& b)
                      {
                          return a.export_name < b.export_name;
                      });

            out << "    // Constants\n";
            for (const auto& c: sorted)
            {
                std::string retType =
                    (c.return_type.find('*') != std::string::npos) ? "*mut c_void" : "c_int";
                out << "    pub fn " << c.export_name << "() -> " << retType << ";\n";
            }
            out << "\n";
        }

        // Free functions
        if (!ffi.free_functions.empty())
        {
            out << "    // Free functions\n";
            for (const auto& f: ffi.free_functions)
            {
                if (!IsValidFunction(f))
                    continue;
                EmitFunctionExternDecl(out, f);
            }
            out << "\n";
        }

        // Class methods
        size_t methodCount = 0;
        size_t skippedCount = 0;
        for (const auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;

            out << "    // " << cls.name << "\n";
            for (const auto& f: cls.methods)
            {
                if (!IsValidFunction(f))
                {
                    ++skippedCount;
                    continue;
                }
                EmitFunctionExternDecl(out, f);
                ++methodCount;
            }
            out << "\n";
        }

        out << "}\n";

        std::cerr << "  sys.rs:              " << ffi.events.size() << " events, "
                  << ffi.keys.size() << " keys, " << ffi.constants.size() << " constants, "
                  << methodCount << " methods";
        if (skippedCount > 0)
            std::cerr << " (" << skippedCount << " skipped)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // src/traits.rs — Trait hierarchy for safe wrappers
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateTraits(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        auto path = srcDir / "traits.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use std::os::raw::c_void;\n\n";

        // Collect all classes that serve as parents.
        std::set<std::string> parentClasses;
        for (const auto& [child, parent]: ffi.parent_map)
            parentClasses.insert(parent);

        // Also add classes that are explicitly parents of other classes.
        for (const auto& cls: ffi.classes)
        {
            if (!cls.parent.empty())
                parentClasses.insert(cls.parent);
        }

        // Root trait: WxObject — all wxWidgets objects impl this.
        out << "/// Base trait for all wxWidgets objects providing raw pointer access.\n";
        out << "pub trait WxObject {\n";
        out << "    /// Returns the underlying raw pointer.\n";
        out << "    fn as_ptr(&self) -> *mut c_void;\n";
        out << "\n";
        out << "    /// Returns true if the underlying pointer is null.\n";
        out << "    fn is_null(&self) -> bool {\n";
        out << "        self.as_ptr().is_null()\n";
        out << "    }\n";
        out << "}\n\n";

        // Generate a trait for each class that serves as a parent, establishing the hierarchy.
        // Sort for deterministic output.
        std::vector<std::string> sortedParents(parentClasses.begin(), parentClasses.end());
        std::sort(sortedParents.begin(), sortedParents.end());

        size_t traitCount = 0;
        for (const auto& parentName: sortedParents)
        {
            std::string traitName = StripPrefix(parentName);

            // Skip wxObject — it's already defined as the root trait WxObject above.
            if (traitName == "Object")
                continue;

            // Find parent of this parent to establish supertrait.
            auto it = ffi.parent_map.find(parentName);
            std::string supertrait;
            if (it != ffi.parent_map.end() && !it->second.empty())
            {
                supertrait = "Wx" + StripPrefix(it->second);
                // Check if the supertrait's parent is also a parent class; if not, use WxObject
                if (parentClasses.find(it->second) == parentClasses.end())
                    supertrait = "WxObject";
            }
            else
            {
                supertrait = "WxObject";
            }

            out << "pub trait Wx" << traitName << ": " << supertrait << " {}\n";
            ++traitCount;
        }

        std::cerr << "  traits.rs:           " << traitCount << " traits\n";
    }

    // -------------------------------------------------------------------------
    // src/events.rs
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateEvents(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        auto path = srcDir / "events.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use crate::sys;\n\n";

        auto sorted = ffi.events;
        std::sort(sorted.begin(), sorted.end(),
                  [](const EventDecl& a, const EventDecl& b)
                  {
                      return a.event_name < b.event_name;
                  });

        std::string lastEvtName;
        for (const auto& e: sorted)
        {
            if (e.event_name == lastEvtName)
                continue;
            lastEvtName = e.event_name;
            out << "#[inline]\n";
            out << "pub fn " << e.event_name << "() -> i32 {\n";
            out << "    unsafe { sys::" << e.export_name << "() as i32 }\n";
            out << "}\n\n";
        }

        std::cerr << "  events.rs:           " << ffi.events.size() << " events\n";
    }

    // -------------------------------------------------------------------------
    // src/keys.rs
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateKeys(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        auto path = srcDir / "keys.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use crate::sys;\n\n";

        auto sorted = ffi.keys;
        std::sort(sorted.begin(), sorted.end(),
                  [](const KeyDecl& a, const KeyDecl& b)
                  {
                      return a.key_name < b.key_name;
                  });

        for (const auto& k: sorted)
        {
            out << "#[inline]\n";
            out << "pub fn " << k.key_name << "() -> i32 {\n";
            out << "    unsafe { sys::" << k.export_name << "() as i32 }\n";
            out << "}\n\n";
        }

        std::cerr << "  keys.rs:             " << ffi.keys.size() << " keys\n";
    }

    // -------------------------------------------------------------------------
    // src/constants.rs
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateConstants(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        auto path = srcDir / "constants.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use std::os::raw::c_void;\n\n";
        out << "use crate::sys;\n\n";

        auto sorted = ffi.constants;
        std::sort(sorted.begin(), sorted.end(),
                  [](const ConstantDecl& a, const ConstantDecl& b)
                  {
                      return a.export_name < b.export_name;
                  });

        for (const auto& c: sorted)
        {
            bool isPointer = (c.return_type.find('*') != std::string::npos);
            std::string retType = isPointer ? "*mut c_void" : "i32";
            std::string cast = isPointer ? "" : " as i32";

            out << "#[inline]\n";
            out << "pub fn " << c.constant_name << "() -> " << retType << " {\n";
            out << "    unsafe { sys::" << c.export_name << "()" << cast << " }\n";
            out << "}\n\n";
        }

        std::cerr << "  constants.rs:        " << ffi.constants.size() << " constants\n";
    }

    // -------------------------------------------------------------------------
    // src/freefuncs.rs
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateFreeFunctions(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        if (ffi.free_functions.empty())
            return;

        auto path = srcDir / "freefuncs.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "#![allow(non_snake_case)]\n\n";
        out << "use std::os::raw::*;\n\n";
        out << "use crate::sys;\n\n";

        size_t count = 0;
        for (const auto& f: ffi.free_functions)
        {
            if (!IsValidFunction(f))
                continue;

            std::string funcName = CFuncName(f);
            std::string retType = RustSafeReturnType(f, "");

            // Collect safe params (no TSelf for free functions)
            std::vector<RustSafeParam> params;
            for (const auto& p: f.params)
            {
                auto expanded = ConvertParamToSafe(p);
                for (auto& sp: expanded)
                    params.push_back(std::move(sp));
            }

            // Function signature
            out << "#[inline]\n";
            out << "pub fn " << funcName << "(";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << params[i].name << ": " << params[i].safe_type;
            }
            out << ")";
            if (!retType.empty())
                out << " -> " << retType;
            out << " {\n";

            // Build FFI call
            std::string call = "sys::" + funcName + "(";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    call += ", ";
                call += params[i].ffi_expr;
            }
            call += ")";

            if (retType.empty())
            {
                out << "    unsafe { " << call << " }\n";
            }
            else
            {
                std::string wrapped = WrapReturnExpr(f, call);
                out << "    unsafe { " << wrapped << " }\n";
            }

            out << "}\n\n";
            ++count;
        }

        std::cerr << "  freefuncs.rs:        " << count << " free functions\n";
    }

    // -------------------------------------------------------------------------
    // Per-class safe wrapper files
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateClassFiles(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        size_t fileCount = 0;
        size_t totalMethods = 0;

        for (const auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;

            auto fileName = RustFileName(cls.name);
            auto path = srcDir / fileName;
            ConditionalFileWriter out(path);
            if (!out.is_open())
            {
                std::cerr << "Error: cannot create " << path << "\n";
                continue;
            }

            EmitClassFile(out, cls, ffi);
            ++fileCount;
        }

        std::cerr << "  class files:         " << fileCount << " files\n";
    }

    void RustEmitter::EmitClassFile(std::ostream& out, const ClassInfo& cls, const ParsedFFI& ffi)
    {
        WriteGeneratedHeader(out);
        out << "#![allow(non_snake_case)]\n\n";
        out << "use std::os::raw::*;\n\n";
        out << "use crate::sys;\n";
        out << "use crate::traits::*;\n\n";

        std::string rustName = StripPrefix(cls.name);
        bool hasDelete = HasDeleteMethod(cls);

        // Struct definition
        out << "pub struct " << rustName << " {\n";
        out << "    ptr: *mut c_void,\n";
        if (hasDelete)
            out << "    owned: bool,\n";
        out << "}\n\n";

        // WxObject trait implementation
        out << "impl WxObject for " << rustName << " {\n";
        out << "    fn as_ptr(&self) -> *mut c_void {\n";
        out << "        self.ptr\n";
        out << "    }\n";
        out << "}\n\n";

        // Trait implementations for parent chain
        {
            // Build the full trait chain: immediate parent up to the root.
            auto chain = BuildTraitChain(cls, ffi);

            // Collect the set of classes that are used as parents (and thus have traits).
            std::set<std::string> parentClasses;
            for (const auto& [child, parent]: ffi.parent_map)
                parentClasses.insert(parent);
            for (const auto& c: ffi.classes)
            {
                if (!c.parent.empty())
                    parentClasses.insert(c.parent);
            }

            for (const auto& parentName: chain)
            {
                std::string traitName = "Wx" + StripPrefix(parentName);
                if (traitName == "WxObject")
                    continue;  // Already explicitly implemented above
                if (parentClasses.find(parentName) != parentClasses.end())
                {
                    out << "impl " << traitName << " for " << rustName << " {}\n";
                }
            }

            // If the class itself is used as a parent, it has a trait too.
            if (parentClasses.find(cls.name) != parentClasses.end())
            {
                out << "impl Wx" << rustName << " for " << rustName << " {}\n";
            }

            if (!chain.empty())
                out << "\n";
        }

        // Drop implementation for classes with Delete
        if (hasDelete)
        {
            // Find the actual Delete method for the correct FFI function name
            std::string deleteFuncName;
            for (const auto& f: cls.methods)
            {
                if (IsDestructor(f))
                {
                    deleteFuncName = CFuncName(f);
                    break;
                }
            }

            out << "impl Drop for " << rustName << " {\n";
            out << "    fn drop(&mut self) {\n";
            out << "        if self.owned && !self.ptr.is_null() {\n";
            out << "            unsafe { sys::" << deleteFuncName << "(self.ptr); }\n";
            out << "        }\n";
            out << "    }\n";
            out << "}\n\n";
        }

        // from_ptr constructor (non-owning)
        out << "impl " << rustName << " {\n";
        out << "    /// Wraps a raw pointer as a non-owning reference. Does not call Delete on "
               "drop.\n";
        out << "    ///\n";
        out << "    /// # Safety\n";
        out << "    /// The pointer must be a valid " << cls.name << " pointer.\n";
        out << "    pub unsafe fn from_ptr(ptr: *mut c_void) -> Self {\n";
        if (hasDelete)
            out << "        Self { ptr, owned: false }\n";
        else
            out << "        Self { ptr }\n";
        out << "    }\n\n";

        // Emit methods
        size_t methodCount = 0;
        std::set<std::string> emittedMethods;
        for (const auto& f: cls.methods)
        {
            if (!IsValidFunction(f))
                continue;

            // Skip destructor — handled by Drop
            if (IsDestructor(f))
                continue;

            // Collect safe params (excluding the first TSelf which becomes &self)
            std::vector<RustSafeParam> params;
            bool selfSkipped = false;
            for (const auto& p: f.params)
            {
                if (!selfSkipped && p.macro_name == "TSelf")
                {
                    selfSkipped = true;
                    continue;
                }
                auto expanded = ConvertParamToSafe(p);
                for (auto& sp: expanded)
                    params.push_back(std::move(sp));
            }

            std::string cFuncName = CFuncName(f);
            std::string retType = RustSafeReturnType(f, rustName);

            if (f.is_constructor && !f.has_self)
            {
                // Constructor: pub fn new(...) -> Option<Self>
                // Only treat as constructor if return type is a pointer.
                bool isPointerReturn = (f.return_type.find('*') != std::string::npos) ||
                                       f.return_macro == "TClass" || f.return_macro == "TSelf";
                if (!isPointerReturn)
                    continue;  // Skip non-pointer constructors (e.g., returns int)

                std::string methodName =
                    (f.method_name == "Create") ? "new" : RustSafeMethodName(f.method_name);

                if (!emittedMethods.insert(methodName).second)
                    continue;  // Skip duplicate method name

                out << "    pub fn " << methodName << "(";
                for (size_t i = 0; i < params.size(); ++i)
                {
                    if (i > 0)
                        out << ", ";
                    out << params[i].name << ": " << params[i].safe_type;
                }
                out << ") -> Option<Self> {\n";

                // Build FFI call
                out << "        let ptr = unsafe { sys::" << cFuncName << "(";
                for (size_t i = 0; i < params.size(); ++i)
                {
                    if (i > 0)
                        out << ", ";
                    out << params[i].ffi_expr;
                }
                out << ") };\n";

                out << "        if ptr.is_null() {\n";
                out << "            None\n";
                out << "        } else {\n";
                if (hasDelete)
                    out << "            Some(Self { ptr, owned: true })\n";
                else
                    out << "            Some(Self { ptr })\n";
                out << "        }\n";
                out << "    }\n\n";
            }
            else
            {
                // Regular method: pub fn method_name(&self, ...) -> RetType
                std::string methodName = RustSafeMethodName(f.method_name);

                if (!emittedMethods.insert(methodName).second)
                    continue;  // Skip duplicate method name

                out << "    pub fn " << methodName << "(&self";
                for (const auto& sp: params)
                    out << ", " << sp.name << ": " << sp.safe_type;
                out << ")";
                if (!retType.empty())
                    out << " -> " << retType;
                out << " {\n";

                // Build FFI call
                std::string call = "sys::" + cFuncName + "(";
                bool first = true;
                if (f.has_self)
                {
                    call += "self.ptr";
                    first = false;
                }
                for (const auto& sp: params)
                {
                    if (!first)
                        call += ", ";
                    call += sp.ffi_expr;
                    first = false;
                }
                call += ")";

                if (retType.empty())
                {
                    out << "        unsafe { " << call << " }\n";
                }
                else
                {
                    std::string wrapped = WrapReturnExpr(f, call);
                    out << "        unsafe { " << wrapped << " }\n";
                }

                out << "    }\n\n";
            }
            ++methodCount;
        }

        out << "}\n";
    }

    // -------------------------------------------------------------------------
    // src/lib.rs — Module root
    // -------------------------------------------------------------------------

    void RustEmitter::GenerateLib(const ParsedFFI& ffi, const fs::path& srcDir)
    {
        auto path = srcDir / "lib.rs";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "#![allow(non_snake_case, non_camel_case_types, unused_imports)]\n\n";

        // Core modules
        out << "pub mod sys;\n";
        out << "pub mod traits;\n";
        out << "pub mod events;\n";
        out << "pub mod keys;\n";
        out << "pub mod constants;\n";

        if (!ffi.free_functions.empty())
            out << "pub mod freefuncs;\n";

        out << "\n";

        // Class modules — one per class with methods
        std::vector<std::string> modNames;
        for (const auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;
            modNames.push_back(RustModuleName(cls.name));
        }

        // Sort for deterministic output
        std::sort(modNames.begin(), modNames.end());

        // Remove duplicates (unlikely but defensive)
        modNames.erase(std::unique(modNames.begin(), modNames.end()), modNames.end());

        for (const auto& modName: modNames)
            out << "pub mod " << modName << ";\n";

        std::cerr << "  lib.rs:              " << modNames.size() << " class modules\n";
    }

}  // namespace kwxgen
