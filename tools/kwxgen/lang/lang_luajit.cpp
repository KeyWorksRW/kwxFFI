// Generated by GitHub Copilot. Directed and reviewed by Ralph Walden.
// Licensed under Apache 2.0. This file is not subject to copyright.

#include "lang_luajit.h"

#include "luajit_type_map.h"

#include "file_writer.h"
#include <algorithm>
#include <filesystem>
#include <iostream>
#include <sstream>
#include <vector>

namespace fs = std::filesystem;

namespace kwxgen
{

    namespace
    {

        void WriteGeneratedHeader(std::ostream& out)
        {
            out << "-- Code generated by kwxgen. DO NOT EDIT.\n";
        }

        // Build a C function name from a FunctionDecl.
        std::string CFuncName(const FunctionDecl& f)
        {
            if (f.class_name.empty())
                return f.method_name;
            return f.class_name + "_" + f.method_name;
        }

        // Emit a single C function declaration for ffi.cdef.
        void EmitCDecl(std::ostream& out, const std::string& returnType,
                       const std::string& funcName, const std::vector<LuaCParam>& params)
        {
            out << "    " << returnType << " " << funcName << "(";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << params[i].c_type << " " << params[i].name;
            }
            out << ");\n";
        }

        // Emit a C declaration from a FunctionDecl.
        void EmitFunctionCDecl(std::ostream& out, const FunctionDecl& f)
        {
            std::string retType = LuaJITReturnType(f.return_type, f.return_macro);
            std::string funcName = CFuncName(f);

            std::vector<LuaCParam> cParams;
            for (const auto& p: f.params)
            {
                auto expanded = ExpandParamToC(p);
                for (auto& cp: expanded)
                    cParams.push_back(std::move(cp));
            }

            EmitCDecl(out, retType, funcName, cParams);
        }

        // Check if a function declaration looks valid (skip malformed ones).
        bool IsValidFunction(const FunctionDecl& f)
        {
            if (f.return_type.find("//") != std::string::npos ||
                f.return_type.find("/*") != std::string::npos ||
                f.return_type.find("*/") != std::string::npos)
                return false;
            if (f.method_name.find("//") != std::string::npos ||
                f.method_name.find("/*") != std::string::npos)
                return false;
            if (f.method_name.empty())
                return false;
            for (const auto& p: f.params)
            {
                if (p.raw_type.find("//") != std::string::npos ||
                    p.raw_type.find("/*") != std::string::npos)
                    return false;
            }
            return true;
        }

    }  // anonymous namespace

    // -------------------------------------------------------------------------
    // LuaJITEmitter public interface
    // -------------------------------------------------------------------------

    void LuaJITEmitter::Generate(const ParsedFFI& ffi, const fs::path& outDir)
    {
        fs::create_directories(outDir);

        GenerateEvents(ffi, outDir);
        GenerateKeys(ffi, outDir);
        GenerateConstants(ffi, outDir);
        GenerateClasses(ffi, outDir);
        GenerateFreeFunctions(ffi, outDir);
        GenerateInit(outDir);

        std::cerr << "LuaJIT: generated 6 files in " << outDir << "\n";
    }

    VerifyResult LuaJITEmitter::Verify(const ParsedFFI& /* ffi */, const fs::path& /* dir */)
    {
        VerifyResult result;
        result.success = false;
        result.messages.push_back("LuaJIT verify: use 'kwxgen verify' command instead");
        return result;
    }

    // -------------------------------------------------------------------------
    // kwxffi_events_gen.lua
    // -------------------------------------------------------------------------

    void LuaJITEmitter::GenerateEvents(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_events_gen.lua";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "local ffi = require(\"ffi\")\n\n";
        out << "ffi.cdef[[\n";

        auto sorted = ffi.events;
        std::sort(sorted.begin(), sorted.end(),
                  [](const EventDecl& a, const EventDecl& b)
                  {
                      return a.event_name < b.event_name;
                  });

        for (const auto& e: sorted)
        {
            out << "    int " << e.export_name << "();\n";
        }

        out << "]]\n";

        std::cerr << "  kwxffi_events_gen.lua:       " << ffi.events.size() << " events\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_keys_gen.lua
    // -------------------------------------------------------------------------

    void LuaJITEmitter::GenerateKeys(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_keys_gen.lua";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "local ffi = require(\"ffi\")\n\n";
        out << "ffi.cdef[[\n";

        auto sorted = ffi.keys;
        std::sort(sorted.begin(), sorted.end(),
                  [](const KeyDecl& a, const KeyDecl& b)
                  {
                      return a.key_name < b.key_name;
                  });

        for (const auto& k: sorted)
        {
            out << "    int " << k.export_name << "();\n";
        }

        out << "]]\n";

        std::cerr << "  kwxffi_keys_gen.lua:         " << ffi.keys.size() << " keys\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_constants_gen.lua
    // -------------------------------------------------------------------------

    void LuaJITEmitter::GenerateConstants(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_constants_gen.lua";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "local ffi = require(\"ffi\")\n\n";
        out << "ffi.cdef[[\n";

        auto sorted = ffi.constants;
        std::sort(sorted.begin(), sorted.end(),
                  [](const ConstantDecl& a, const ConstantDecl& b)
                  {
                      return a.export_name < b.export_name;
                  });

        for (const auto& c: sorted)
        {
            std::string retType =
                (c.return_type.find('*') != std::string::npos) ? "void*" : c.return_type;
            out << "    " << retType << " " << c.export_name << "();\n";
        }

        out << "]]\n";

        std::cerr << "  kwxffi_constants_gen.lua:    " << ffi.constants.size() << " constants\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_classes_gen.lua
    // -------------------------------------------------------------------------

    void LuaJITEmitter::GenerateClasses(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_classes_gen.lua";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "local ffi = require(\"ffi\")\n\n";

        size_t methodCount = 0;
        size_t skippedCount = 0;

        for (const auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;

            out << "-- " << cls.name << "\n";
            out << "ffi.cdef[[\n";

            for (const auto& f: cls.methods)
            {
                if (!IsValidFunction(f))
                {
                    ++skippedCount;
                    continue;
                }
                EmitFunctionCDecl(out, f);
                ++methodCount;
            }

            out << "]]\n\n";
        }

        std::cerr << "  kwxffi_classes_gen.lua:      " << methodCount << " methods";
        if (skippedCount > 0)
            std::cerr << " (" << skippedCount << " skipped)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_freefuncs_gen.lua
    // -------------------------------------------------------------------------

    void LuaJITEmitter::GenerateFreeFunctions(const ParsedFFI& ffi, const fs::path& outDir)
    {
        if (ffi.free_functions.empty())
            return;

        auto path = outDir / "kwxffi_freefuncs_gen.lua";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "local ffi = require(\"ffi\")\n\n";
        out << "ffi.cdef[[\n";

        size_t count = 0;
        for (const auto& f: ffi.free_functions)
        {
            if (!IsValidFunction(f))
                continue;
            EmitFunctionCDecl(out, f);
            ++count;
        }

        out << "]]\n";

        std::cerr << "  kwxffi_freefuncs_gen.lua:    " << count << " free functions\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_gen.lua â€” main entry point, loads all sub-files and returns lib
    // -------------------------------------------------------------------------

    void LuaJITEmitter::GenerateInit(const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_gen.lua";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "-- Main entry point for kwxFFI LuaJIT bindings.\n";
        out << "-- Usage: local wx = require(\"kwxffi_gen\")\n";
        out << "--        wx.wxButton_Create(parent, id, label, x, y, w, h, style)\n";
        out << "\n";
        out << "require(\"kwxffi_events_gen\")\n";
        out << "require(\"kwxffi_keys_gen\")\n";
        out << "require(\"kwxffi_constants_gen\")\n";
        out << "require(\"kwxffi_classes_gen\")\n";
        out << "require(\"kwxffi_freefuncs_gen\")\n";
        out << "\n";
        out << "return require(\"ffi\").load(\"kwxFFI\")\n";

        std::cerr << "  kwxffi_gen.lua:              main entry point\n";
    }

}  // namespace kwxgen
