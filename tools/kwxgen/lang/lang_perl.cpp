// Generated by GitHub Copilot. Directed and reviewed by Ralph Walden.
// Licensed under Apache 2.0. This file is not subject to copyright.

#include "lang_perl.h"

#include "perl_type_map.h"

#include "file_writer.h"
#include <algorithm>
#include <filesystem>
#include <iostream>
#include <vector>

namespace fs = std::filesystem;

namespace kwxgen
{

    namespace
    {

        void WriteGeneratedHeader(std::ostream& out)
        {
            out << "# Code generated by kwxgen. DO NOT EDIT.\n";
        }

        // Build a C function name from a FunctionDecl.
        std::string CFuncName(const FunctionDecl& f)
        {
            if (f.class_name.empty())
                return f.method_name;
            return f.class_name + "_" + f.method_name;
        }

        // Emit a single FFI::Platypus attach declaration.
        void EmitAttach(std::ostream& out, const std::string& funcName,
                        const std::vector<PerlParam>& params, const std::string& returnType)
        {
            out << "$ffi->attach( " << funcName << " => [";
            for (size_t i = 0; i < params.size(); ++i)
            {
                if (i > 0)
                    out << ", ";
                out << "'" << params[i].platypus_type << "'";
            }
            out << "] => '" << returnType << "' );\n";
        }

        // Emit an attach declaration from a FunctionDecl.
        void EmitFunctionAttach(std::ostream& out, const FunctionDecl& f)
        {
            std::string retType = PerlReturnType(f.return_type, f.return_macro);
            std::string funcName = CFuncName(f);

            std::vector<PerlParam> pParams;
            for (const auto& p: f.params)
            {
                auto expanded = ExpandParamToPerl(p);
                for (auto& pp: expanded)
                    pParams.push_back(std::move(pp));
            }

            EmitAttach(out, funcName, pParams, retType);
        }

        // Check if a function declaration looks valid (skip malformed ones).
        bool IsValidFunction(const FunctionDecl& f)
        {
            if (f.return_type.find("//") != std::string::npos ||
                f.return_type.find("/*") != std::string::npos ||
                f.return_type.find("*/") != std::string::npos)
                return false;
            if (f.method_name.find("//") != std::string::npos ||
                f.method_name.find("/*") != std::string::npos)
                return false;
            if (f.method_name.empty())
                return false;
            for (const auto& p: f.params)
            {
                if (p.raw_type.find("//") != std::string::npos ||
                    p.raw_type.find("/*") != std::string::npos)
                    return false;
            }
            return true;
        }

    }  // anonymous namespace

    // -------------------------------------------------------------------------
    // PerlEmitter public interface
    // -------------------------------------------------------------------------

    void PerlEmitter::Generate(const ParsedFFI& ffi, const fs::path& outDir)
    {
        fs::create_directories(outDir);

        GenerateEvents(ffi, outDir);
        GenerateKeys(ffi, outDir);
        GenerateConstants(ffi, outDir);
        GenerateClasses(ffi, outDir);
        GenerateFreeFunctions(ffi, outDir);
        GenerateInit(outDir);

        std::cerr << "Perl: generated 6 files in " << outDir << "\n";
    }

    VerifyResult PerlEmitter::Verify(const ParsedFFI& /* ffi */, const fs::path& /* dir */)
    {
        VerifyResult result;
        result.success = false;
        result.messages.push_back("Perl verify: use 'kwxgen verify' command instead");
        return result;
    }

    // -------------------------------------------------------------------------
    // kwxffi_events_gen.pl
    // -------------------------------------------------------------------------

    void PerlEmitter::GenerateEvents(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_events_gen.pl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use strict;\n";
        out << "use warnings;\n\n";

        auto sorted = ffi.events;
        std::sort(sorted.begin(), sorted.end(),
                  [](const EventDecl& a, const EventDecl& b)
                  {
                      return a.event_name < b.event_name;
                  });

        for (const auto& e: sorted)
        {
            out << "$ffi->attach( " << e.export_name << " => [] => 'int' );\n";
        }

        std::cerr << "  kwxffi_events_gen.pl:       " << ffi.events.size() << " events\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_keys_gen.pl
    // -------------------------------------------------------------------------

    void PerlEmitter::GenerateKeys(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_keys_gen.pl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use strict;\n";
        out << "use warnings;\n\n";

        auto sorted = ffi.keys;
        std::sort(sorted.begin(), sorted.end(),
                  [](const KeyDecl& a, const KeyDecl& b)
                  {
                      return a.key_name < b.key_name;
                  });

        for (const auto& k: sorted)
        {
            out << "$ffi->attach( " << k.export_name << " => [] => 'int' );\n";
        }

        std::cerr << "  kwxffi_keys_gen.pl:         " << ffi.keys.size() << " keys\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_constants_gen.pl
    // -------------------------------------------------------------------------

    void PerlEmitter::GenerateConstants(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_constants_gen.pl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use strict;\n";
        out << "use warnings;\n\n";

        auto sorted = ffi.constants;
        std::sort(sorted.begin(), sorted.end(),
                  [](const ConstantDecl& a, const ConstantDecl& b)
                  {
                      return a.export_name < b.export_name;
                  });

        for (const auto& c: sorted)
        {
            std::string retType = (c.return_type.find('*') != std::string::npos) ? "opaque" : "int";
            out << "$ffi->attach( " << c.export_name << " => [] => '" << retType << "' );\n";
        }

        std::cerr << "  kwxffi_constants_gen.pl:    " << ffi.constants.size() << " constants\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_classes_gen.pl
    // -------------------------------------------------------------------------

    void PerlEmitter::GenerateClasses(const ParsedFFI& ffi, const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_classes_gen.pl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use strict;\n";
        out << "use warnings;\n\n";

        size_t methodCount = 0;
        size_t skippedCount = 0;

        for (const auto& cls: ffi.classes)
        {
            if (cls.methods.empty())
                continue;

            out << "# " << cls.name << "\n";

            for (const auto& f: cls.methods)
            {
                if (!IsValidFunction(f))
                {
                    ++skippedCount;
                    continue;
                }
                EmitFunctionAttach(out, f);
                ++methodCount;
            }

            out << "\n";
        }

        std::cerr << "  kwxffi_classes_gen.pl:      " << methodCount << " methods";
        if (skippedCount > 0)
            std::cerr << " (" << skippedCount << " skipped)";
        std::cerr << "\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_freefuncs_gen.pl
    // -------------------------------------------------------------------------

    void PerlEmitter::GenerateFreeFunctions(const ParsedFFI& ffi, const fs::path& outDir)
    {
        if (ffi.free_functions.empty())
            return;

        auto path = outDir / "kwxffi_freefuncs_gen.pl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "use strict;\n";
        out << "use warnings;\n\n";

        size_t count = 0;
        for (const auto& f: ffi.free_functions)
        {
            if (!IsValidFunction(f))
                continue;
            EmitFunctionAttach(out, f);
            ++count;
        }

        std::cerr << "  kwxffi_freefuncs_gen.pl:    " << count << " free functions\n";
    }

    // -------------------------------------------------------------------------
    // kwxffi_gen.pl â€” main entry point, sets up FFI::Platypus and loads sub-files
    // -------------------------------------------------------------------------

    void PerlEmitter::GenerateInit(const fs::path& outDir)
    {
        auto path = outDir / "kwxffi_gen.pl";
        ConditionalFileWriter out(path);
        if (!out.is_open())
        {
            std::cerr << "Error: cannot create " << path << "\n";
            return;
        }

        WriteGeneratedHeader(out);
        out << "# Main entry point for kwxFFI Perl bindings.\n";
        out << "# Usage: require 'kwxffi_gen.pl';\n";
        out << "#        my $ptr = wxButton_Create($parent, $id, $label, $x, $y, $w, $h, "
               "$style);\n";
        out << "\n";
        out << "use strict;\n";
        out << "use warnings;\n";
        out << "use FFI::Platypus 2.00;\n\n";
        out << "our $ffi = FFI::Platypus->new( api => 2, lib => 'kwxFFI' );\n\n";
        out << "require 'kwxffi_events_gen.pl';\n";
        out << "require 'kwxffi_keys_gen.pl';\n";
        out << "require 'kwxffi_constants_gen.pl';\n";
        out << "require 'kwxffi_classes_gen.pl';\n";
        out << "require 'kwxffi_freefuncs_gen.pl';\n";
        out << "\n1;\n";

        std::cerr << "  kwxffi_gen.pl:              main entry point\n";
    }

}  // namespace kwxgen
